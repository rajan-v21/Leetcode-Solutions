#include<bits/stdc++.h>
using namespace std;

class Solution {
public:
    vector<int> maxSlidingWindow(vector<int>& nums, int k) {
        int left = 0, right = 0;
        deque<int> q;
        vector<int> res;
        while(right < nums.size()){
            while(!q.empty() && q.back() < nums[right]) q.pop_back();
            q.push_back(nums[right]);
            if(right - left + 1 == k){
                res.push_back(q.front());
                if(nums[left] == q.front()) q.pop_front();
                left++;
            }
            if(right - left + 1 < k) right++;
        }
        return res;
    }
};

int main(){
	Solution s;
    vector<int> v = {-1,3,1,2,0,5};
    int k = 3;
    vector<int> sol = s.maxSlidingWindow(v, k);
    for(int i=0; i < sol.size(); i++) cout<<sol[i]<<" ";
}

/*
TC: O(n) SC: O(n)

Intuition:

Intuition is to keep track of first element in deque, which will always be the maximum element found up till the traverse
and checking every new element at right pointer with the last element of deque and removing all the elements from back untill
current element is less than last element in deque to maintain the monotonicity of queue i.e to keep element in deque in
non-decreasing order.
For eg: if deque contains elements 4 3 0 -2 and if the element at right pointer of vector nums turns to be 3 then we remove
all the elements up till 0 and insert 2 at last. Then elements in deque will be 4 3 2.

until the right pointer hits window.
1. Traverse towards right and keep inserting the element in the deque if the element on right pointer is smaller than last
element in deque.
2. But if we encounter any element bigger than the last element of deque, we start popping all the elements from behind to
maintain the monotonicity of deque.
3. We also check that is the length  at each right

check the array monotically using deque(queue cant be used for monotonic check
bcz queue only allow FIFO and we are poping ele from back in this)
by checking and poping any no smaller than nums's right past last ele of deque
and keep travesing towards right until window hits.
then get the first element of the deque which will always be max in window.
now whenever we are sliding our window we will check that our window's start 
(nums's left) is going past the max element in deque (first ele of deque), 
if yes that means our max element in deque (first ele of deque) wont be max in
new window, so discard it by poping from deque
then we set start of new window and repeat until right hits n.
*/
